

import pandas as pd
import streamlit as st
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import plotly.express as px
import plotly.graph_objects as go
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.statespace.sarimax import SARIMAX
from statsmodels.tsa.arima.model import ARIMA
from datetime import datetime, timedelta
import warnings
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential # type: ignore
from tensorflow.keras.layers import LSTM, Dense # type: ignore
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from statsmodels.stats.diagnostic import acorr_ljungbox

warnings.filterwarnings("ignore")

# Custom CSS for styling with theme support
def apply_theme(theme):
    if theme == "Dark":
        css = """
            <style>
            .main { background-color: #2c3e50; color: #ecf0f1; font-family: 'Poppins', sans-serif; }
            .stButton>button { background-color: #ff4b5c; color: white; border-radius: 8px; border: none; padding: 10px 20px; font-weight: bold; transition: 0.3s; }
            .stButton>button:hover { background-color: #e04352; box-shadow: 0 2px 5px rgba(255,255,255,0.2); }
            .stSelectbox, .stFileUploader, .stDateInput, .stTextInput { background-color: #34495e; color: #ecf0f1; border-radius: 8px; padding: 10px; box-shadow: 0 1px 3px rgba(255,255,255,0.1); }
            .stMetric { background-color: #34495e; color: #ecf0f1; border-radius: 8px; padding: 15px; box-shadow: 0 2px 5px rgba(255,255,255,0.1); margin: 10px 0; }
            .card { background-color: #34495e; color: #ecf0f1; border-radius: 10px; padding: 20px; margin: 10px 0; box-shadow: 0 2px 5px rgba(255,255,255,0.1); }
            h1, h2, h3, h4 { color: #ecf0f1; }
            .sidebar .sidebar-content { background-color: #2c3e50; color: #ecf0f1; }
            .sidebar .stButton>button { background-color: #1abc9c; }
            .sidebar .stButton>button:hover { background-color: #16a085; }
            .plotly-chart { border-radius: 10px; overflow: hidden; background-color: #34495e; }
            .dataframe th { background-color: #1a73e8; color: white; padding: 12px; }
            .dataframe td { padding: 12px; border-bottom: 1px solid #ddd; }
            .dataframe tr:nth-child(even) { background-color: #f9f9f9; }
            .dataframe tr:hover { background-color: #e6f0fa; }
            @keyframes pulse {
                0% { transform: scale(1); }
                50% { transform: scale(1.1); }
                100% { transform: scale(1); }
            }
            .stButton>button { animation: pulse 2s infinite; }
            @keyframes fadeIn {
                0% { opacity: 0; transform: translateY(20px); }
                100% { opacity: 1; transform: translateY(0); }
            }
            .fade-in { animation: fadeIn 1s ease-in-out; }
            </style>
        """
    else:  # Light theme
        css = """
            <style>
            .main { background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); font-family: 'Poppins', sans-serif; }
            .stButton>button { background-color: #1a73e8; color: white; border-radius: 25px; border: none; padding: 10px 30px; font-weight: bold; transition: 0.3s; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
            .stButton>button:hover { background-color: #ff6f61; transform: scale(1.05); box-shadow: 0 6px 12px rgba(0,0,0,0.2); }
            .stSelectbox, .stFileUploader, .stDateInput, .stTextInput { background-color: white; border-radius: 8px; padding: 10px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
            .stMetric { background-color: white; border-radius: 8px; padding: 15px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin: 10px 0; }
            .card { background-color: white; border-radius: 15px; padding: 20px; margin: 10px 0; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
            h1, h2, h3, h4 { color: #2c3e50; }
            .sidebar .sidebar-content { background-color: #34495e; color: white; }
            .sidebar .stButton>button { background-color: #1abc9c; }
            .sidebar .stButton>button:hover { background-color: #16a085; }
            .plotly-chart { border-radius: 10px; overflow: hidden; background-color: white; }
            .dataframe { border-collapse: collapse; width: 100%; margin: 20px 0; box-shadow: 0 4px 8px rgba(0,0,0,0.1); border-radius: 10px; overflow: hidden; }
            .dataframe th { background-color: #1a73e8; color: white; padding: 12px; }
            .dataframe td { padding: 12px; border-bottom: 1px solid #ddd; }
            .dataframe tr:nth-child(even) { background-color: #f9f9f9; }
            .dataframe tr:hover { background-color: #e6f0fa; }
            @keyframes pulse {
                0% { transform: scale(1); }
                50% { transform: scale(1.1); }
                100% { transform: scale(1); }
            }
            .stButton>button { animation: pulse 2s infinite; }
            @keyframes fadeIn {
                0% { opacity: 0; transform: translateY(20px); }
                100% { opacity: 1; transform: translateY(0); }
            }
            .fade-in { animation: fadeIn 1s ease-in-out; }
            </style>
        """
    st.markdown(css, unsafe_allow_html=True)

# Initialize session state
if 'df_covid' not in st.session_state:
    st.session_state.df_covid = None
if 'df_malaria' not in st.session_state:
    st.session_state.df_malaria = None
if 'user_profile' not in st.session_state:
    st.session_state.user_profile = {'name': '', 'email': '', 'analyses_run': 0}
if 'settings' not in st.session_state:
    st.session_state.settings = {'theme': 'Light', 'look_back_period': 60}

# Apply theme
apply_theme(st.session_state.settings['theme'])

# Sidebar navigation
st.sidebar.title("🦠 Disease Prediction Dashboard")
st.sidebar.markdown("Analyze and predict COVID-19 and malaria cases in India.")
page = st.sidebar.radio("Go to:", ["Profile", "Home", "COVID-19 Analysis", "Malaria Analysis", "Combined Insights", "Settings"])

# Header
st.markdown("""
    <div class="card">
        <h1>🦠 Disease Prediction Dashboard</h1>
        <p style="font-size: 18px;">Analyze and predict COVID-19 and malaria cases across India using ARIMA models.</p>
    </div>
""", unsafe_allow_html=True)

# LSTM Forecasting Function
@st.cache_data
def lstm_forecast(series, steps, look_back=None):
    try:
        look_back = look_back if look_back is not None else st.session_state.settings['look_back_period']
        if series is None or len(series) == 0:
            raise ValueError("Input series is None or empty")
        if series.isna().all():
            raise ValueError("Input series contains only NaN values")
        if len(series) < look_back:
            raise ValueError(f"Input series has {len(series)} data points, but look_back={look_back} is required")

        scaler = MinMaxScaler(feature_range=(0, 1))
        series_values = series.values.reshape(-1, 1)
        scaled_series = scaler.fit_transform(series_values)

        def create_sequences(data, look_back):
            X, y = [], []
            for i in range(len(data) - look_back):
                X.append(data[i:(i + look_back), 0])
                y.append(data[i + look_back, 0])
            return np.array(X), np.array(y)

        X, y = create_sequences(scaled_series, look_back)
        if len(X) == 0 or len(y) == 0:
            st.warning(f"No sequences created. Series length={len(series)}, look_back={look_back}. Returning flat forecast.")
            return pd.Series(
                [series.iloc[-1] if not pd.isna(series.iloc[-1]) else 0] * steps,
                index=pd.date_range(start=series.index[-1] + timedelta(days=1), periods=steps, freq='D')
            ), float('nan'), float('nan')

        X = X.reshape((X.shape[0], X.shape[1], 1))
        train_size = int(len(X) * 0.8)
        if train_size == 0:
            raise ValueError("Training set is empty after splitting. Increase data size or reduce look_back.")

        X_train, X_val = X[:train_size], X[train_size:]
        y_train, y_val = y[:train_size], y[train_size:]

        model = Sequential()
        model.add(LSTM(50, activation='relu', input_shape=(look_back, 1), return_sequences=True))
        model.add(LSTM(50, activation='relu'))
        model.add(Dense(1))
        model.compile(optimizer='adam', loss='mse')
        model.fit(X_train, y_train, epochs=50, batch_size=32, verbose=0, validation_data=(X_val, y_val))

        last_sequence = scaled_series[-look_back:].reshape((1, look_back, 1))
        forecast = []
        current_sequence = last_sequence.copy()
        for _ in range(steps):
            pred = model.predict(current_sequence, verbose=0)
            forecast.append(pred[0, 0])
            current_sequence = np.roll(current_sequence, -1, axis=1)
            current_sequence[0, -1, 0] = pred[0, 0]

        forecast = np.array(forecast).reshape(-1, 1)
        forecast = scaler.inverse_transform(forecast).flatten()
        forecast_series = pd.Series(
            forecast,
            index=pd.date_range(start=series.index[-1] + timedelta(days=1), periods=steps, freq='D')
        )

        mse, r2 = float('nan'), float('nan')
        if len(X_val) > 0:
            val_pred = model.predict(X_val, verbose=0)
            val_pred = scaler.inverse_transform(val_pred).flatten()
            val_true = scaler.inverse_transform(y_val.reshape(-1, 1)).flatten()
            mse = mean_squared_error(val_true, val_pred)
            r2 = r2_score(val_true, val_pred)

        return forecast_series.clip(lower=0), mse, r2
    except Exception as e:
        st.error(f"Error in LSTM forecasting: {str(e)}")
        default_start_date = pd.to_datetime('2025-05-27') if series is None or series.empty else series.index[-1]
        return pd.Series(
            [0] * steps,
            index=pd.date_range(start=default_start_date + timedelta(days=1), periods=steps, freq='D')
        ), float('nan'), float('nan')

# COVID-19 Data Parsing
@st.cache_data
def parse_covid_data(raw_data):
    try:
        lines = raw_data.strip().split('\n')
        headers = lines[0].split()
        data = [line.split(maxsplit=len(headers)-1) for line in lines[1:]]
        df = pd.DataFrame(data, columns=headers)
        df['Date_reported'] = pd.to_datetime(df['Date_reported'], format='%d-%m-%Y')
        for col in ['New_cases', 'Cumulative_cases', 'New_deaths', 'Cumulative_deaths']:
            df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)
        df['New_cases'] = df['New_cases'].clip(lower=0)
        df['New_deaths'] = df['New_deaths'].clip(lower=0)
        return df
    except Exception as e:
        st.error(f"Error parsing COVID-19 data: {str(e)}")
        return None

# COVID-19 Data Simulation
@st.cache_data
def generate_simulated_covid_data(initial_data):
    try:
        df = initial_data.copy()
        last_date = df['Date_reported'].max()
        last_cumulative_cases = df['Cumulative_cases'].iloc[-1]
        last_cumulative_deaths = df['Cumulative_deaths'].iloc[-1]
        end_date = pd.to_datetime('2025-05-27')  # Updated to current date

        def generate_wave(start_day, peak_day, end_day, start_cases, peak_cases):
            days = []
            for day in range(start_day, peak_day + 1):
                progress = (day - start_day) / (peak_day - start_day)
                cases = int(start_cases + (peak_cases - start_cases) * progress * progress)
                days.append(cases)
            for day in range(peak_day + 1, end_day + 1):
                progress = (day - peak_day) / (end_day - peak_day)
                cases = int(peak_cases * (1 - progress * progress))
                days.append(cases)
            return days

        wave1 = generate_wave(0, 150, 300, 100, 100000)
        wave2 = generate_wave(0, 40, 100, 30000, 400000)
        wave3 = generate_wave(0, 30, 90, 10000, 350000)
        wave4 = generate_wave(0, 20, 60, 5000, 50000)
        wave5 = generate_wave(0, 15, 45, 2000, 25000)
        wave6 = generate_wave(0, 15, 40, 1000, 15000)
        wave7 = generate_wave(0, 10, 30, 500, 8000)

        def get_new_cases(date):
            year = date.year
            month = date.month
            total_days = (date - pd.to_datetime('2020-03-01')).days
            if year == 2020 or (year == 2021 and month < 3):
                day_in_wave = total_days % len(wave1)
                return wave1[day_in_wave]
            elif year == 2021 and 3 <= month <= 6:
                day_in_wave = (total_days - (pd.to_datetime('2021-03-01') - pd.to_datetime('2020-03-01')).days) % len(wave2)
                return wave2[day_in_wave]
            elif (year == 2021 and month >= 12) or (year == 2022 and month <= 2):
                day_in_wave = (total_days - (pd.to_datetime('2021-12-01') - pd.to_datetime('2020-03-01')).days) % len(wave3)
                return wave3[day_in_wave]
            elif year == 2022 and 6 <= month <= 8:
                day_in_wave = (total_days - (pd.to_datetime('2022-06-01') - pd.to_datetime('2020-03-01')).days) % len(wave4)
                return wave4[day_in_wave]
            elif year == 2023 and 1 <= month <= 3:
                day_in_wave = (total_days - (pd.to_datetime('2023-01-01') - pd.to_datetime('2020-03-01')).days) % len(wave5)
                return wave5[day_in_wave]
            elif year == 2023 and 9 <= month <= 11:
                day_in_wave = (total_days - (pd.to_datetime('2023-09-01') - pd.to_datetime('2020-03-01')).days) % len(wave6)
                return wave6[day_in_wave]
            elif year == 2024 and 3 <= month <= 5:
                day_in_wave = (total_days - (pd.to_datetime('2024-03-01') - pd.to_datetime('2020-03-01')).days) % len(wave7)
                return wave7[day_in_wave]
            elif year == 2024 and 10 <= month <= 12:
                day_in_wave = (total_days - (pd.to_datetime('2024-10-01') - pd.to_datetime('2020-03-01')).days) % len(wave7)
                return int(wave7[day_in_wave] * 0.7)
            elif year == 2025 and 1 <= month <= 5:
                day_in_wave = (total_days - (pd.to_datetime('2025-01-01') - pd.to_datetime('2020-03-01')).days) % len(wave7)
                return int(wave7[day_in_wave] * 0.5)
            else:
                return np.random.randint(400, 500)

        current_date = last_date + timedelta(days=1)
        new_rows = []
        while current_date <= end_date:
            new_cases = get_new_cases(current_date)
            last_cumulative_cases += new_cases
            death_rate = 0.02 if current_date <= pd.to_datetime('2021-03-01') else \
                         0.012 if current_date <= pd.to_datetime('2021-12-01') else \
                         0.005 if current_date <= pd.to_datetime('2022-07-01') else \
                         0.002 if current_date <= pd.to_datetime('2023-01-01') else \
                         0.001 if current_date <= pd.to_datetime('2024-01-01') else 0.0005
            new_deaths = int(new_cases * death_rate)
            last_cumulative_deaths += new_deaths
            new_rows.append({
                'Date_reported': current_date,
                'Country': 'India',
                'WHO_region': 'SEAR',
                'New_cases': new_cases,
                'Cumulative_cases': last_cumulative_cases,
                'New_deaths': new_deaths,
                'Cumulative_deaths': last_cumulative_deaths
            })
            current_date += timedelta(days=1)
        full_data = pd.concat([df, pd.DataFrame(new_rows)], ignore_index=True)
        full_data = full_data.sort_values('Date_reported')
        return full_data
    except Exception as e:
        st.error(f"Error generating simulated COVID-19 data: {str(e)}")
        return None

# Malaria Data Preprocessing
@st.cache_data
def preprocess_malaria_data(uploaded_file):
    try:
        df_malaria = pd.read_csv(uploaded_file)
        if df_malaria.empty:
            return None
        merged_rows = []
        skip_next = False
        for i in range(len(df_malaria)):
            if skip_next:
                skip_next = False
                continue
            row = df_malaria.iloc[i].fillna("")
            if str(row[1]).strip() in ["", "0"] and i > 0:
                prev_row = df_malaria.iloc[i - 1].fillna("")
                merged = prev_row.combine_first(row)
                merged_rows[-1] = merged
            else:
                merged_rows.append(row)
        df_malaria = pd.DataFrame(merged_rows).reset_index(drop=True)
        df_malaria.columns = df_malaria.iloc[0]
        df_malaria = df_malaria[1:].reset_index(drop=True)
        df_malaria = df_malaria.iloc[:-1]
        df_malaria.columns = [
            "Sr", "STATE_UT", "BSE_2020", "Malaria_2020", "Pf_2020", "Deaths_2020",
            "BSE_2021", "Malaria_2021", "Pf_2021", "Deaths_2021",
            "BSE_2022", "Malaria_2022", "Pf_2022", "Deaths_2022",
            "BSE_2023", "Malaria_2023", "Pf_2023", "Deaths_2023",
            "BSE_2024", "Malaria_2024", "Pf_2024", "Deaths_2024"
        ]
        num_cols = df_malaria.columns[2:]
        df_malaria[num_cols] = df_malaria[num_cols].apply(pd.to_numeric, errors="coerce")
        df_malaria.drop("Sr", axis=1, inplace=True)
        return df_malaria
    except Exception as e:
        st.error(f"Error preprocessing malaria data: {str(e)}")
        return None

# Malaria Visualizations
@st.cache_data
def generate_malaria_visualizations(df_malaria):
    try:
        visualizations = {}
        numeric_cols = df_malaria.select_dtypes(include=[np.number]).columns
        df_numeric = df_malaria[numeric_cols]
        corr_matrix = df_numeric.corr()
        sns.set_style('darkgrid')  # Fixed: Use Seaborn's darkgrid style
        fig1, ax1 = plt.subplots(figsize=(12, 8))
        sns.heatmap(corr_matrix, annot=True, fmt=".2f", cmap="Spectral", linewidths=0.5, ax=ax1)
        ax1.set_title("Correlation Matrix for Malaria Cases", fontsize=14, pad=15)
        visualizations['corr_matrix'] = fig1

        sns.set_style('darkgrid')  # Fixed: Use Seaborn's darkgrid style
        fig2, ax2 = plt.subplots(figsize=(12, 6))
        palette = sns.color_palette("Set2", 6)
        for i, year in enumerate(range(2020, 2025)):
            col = f"Malaria_{year}"
            if col in df_malaria.columns:
                sns.kdeplot(df_malaria[col], label=f"{year} (Actual)", fill=True, alpha=0.5, color=palette[i], ax=ax2)
        if "Predicted_Malaria_2025" in df_malaria.columns:
            sns.kdeplot(df_malaria["Predicted_Malaria_2025"], label="2025 (Forecast)", fill=True, alpha=0.5, 
                        color=palette[5], linestyle='--', ax=ax2)
        ax2.set_xlabel("Number of Malaria Cases", fontsize=12)
        ax2.set_ylabel("Density", fontsize=12)
        ax2.legend(title="Year")
        ax2.set_title("Malaria Cases Distribution (2020-2025)", fontsize=14, pad=15)
        visualizations['kde_plot'] = fig2

        malaria_cols = [col for col in df_malaria.columns if "Malaria_" in col]
        df_malaria['Avg_Malaria'] = df_malaria[malaria_cols].mean(axis=1)
        top_states = df_malaria.nlargest(10, 'Avg_Malaria')[['STATE_UT', 'Avg_Malaria']]
        sns.set_style('darkgrid')  # Fixed: Use Seaborn's darkgrid style
        fig3, ax3 = plt.subplots(figsize=(10, 6))
        sns.barplot(data=top_states, y='STATE_UT', x='Avg_Malaria', palette='magma', ax=ax3)
        ax3.set_title("Top 10 States by Average Malaria Cases (2020-2024)", fontsize=14, pad=15)
        ax3.set_xlabel("Average Malaria Cases", fontsize=12)
        ax3.set_ylabel("State/UT", fontsize=12)
        visualizations['top_states'] = fig3
        return visualizations
    except Exception as e:
        st.error(f"Error generating malaria visualizations: {str(e)}")
        return {}

# Malaria Feature Engineering
@st.cache_data
def perform_malaria_feature_engineering(df_malaria):
    try:
        df_malaria = df_malaria.copy()
        malaria_cols = [f"Malaria_{y}" for y in range(2020, 2025)]
        df_malaria["Avg_Malaria_Cases"] = df_malaria[malaria_cols].mean(axis=1)
        for year in range(2020, 2025):
            df_malaria[f"Fatality_Rate_{year}"] = np.where(
                df_malaria[f"Malaria_{year}"] > 0,
                df_malaria[f"Deaths_{year}"] / df_malaria[f"Malaria_{year}"],
                0
            )
        for year in range(2021, 2025):
            df_malaria[f"Malaria_Lag_{year}"] = df_malaria[f"Malaria_{year-1}"]
        def categorize_risk(row):
            avg = row["Avg_Malaria_Cases"]
            return "High-Risk" if avg > 15000 else "Medium-Risk" if avg > 5000 else "Low-Risk"
        df_malaria["Risk_Category"] = df_malaria.apply(categorize_risk, axis=1)
        df_malaria["Avg_Malaria_Cases"] = df_malaria["Avg_Malaria_Cases"].round(0).astype(int)
        visualizations = {}
        sns.set_style('darkgrid')  # Fixed: Use Seaborn's darkgrid style
        fig4, ax4 = plt.subplots(figsize=(8, 5))
        sns.countplot(data=df_malaria, x='Risk_Category', palette='Set2', ax=ax4)
        ax4.set_title("Risk Category Distribution", fontsize=14, pad=15)
        ax4.set_xlabel("Risk Category", fontsize=12)
        ax4.set_ylabel("Count", fontsize=12)
        visualizations['risk_category'] = fig4
        sns.set_style('darkgrid')  # Fixed: Use Seaborn's darkgrid style
        fig5, ax5 = plt.subplots(figsize=(15, 8))
        palette = {"High-Risk": "#e74c3c", "Medium-Risk": "#f39c12", "Low-Risk": "#2ecc71"}
        sns.barplot(data=df_malaria, x="STATE_UT", y="Avg_Malaria_Cases", hue="Risk_Category",
                    palette=palette, hue_order=["High-Risk", "Medium-Risk", "Low-Risk"], ax=ax5)
        ax5.set_title("State-wise Malaria Risk Categorization", fontsize=14, pad=15)
        ax5.set_xlabel("State/UT", fontsize=12)
        ax5.set_ylabel("Avg. Malaria Cases", fontsize=12)
        ax5.tick_params(axis='x', rotation=90)
        visualizations['state_risk'] = fig5
        return df_malaria, visualizations
    except Exception as e:
        st.error(f"Error in malaria feature engineering: {str(e)}")
        return df_malaria, {}

# Malaria ARIMA Predictions
@st.cache_data
def run_malaria_arima(df_malaria):
    try:
        df_malaria = df_malaria.copy()
        malaria_cols = [f"Malaria_{y}" for y in range(2020, 2025)]
        predictions = []
        mse_total = 0
        actuals = []
        forecasts = []
        for index, row in df_malaria.iterrows():
            series = [row[col] for col in malaria_cols]
            series = [0 if pd.isna(x) else x for x in series]
            train = series[:4]
            test = series[4]
            try:
                model = ARIMA(train, order=(1, 1, 0))
                model_fit = model.fit()
                forecast = model_fit.forecast(steps=2)
                pred_2024 = forecast[0]
                pred_2025 = forecast[1]
                predictions.append(pred_2025 if pred_2025 > 0 else 0)
                mse_total += (test - pred_2024) ** 2
                actuals.append(test)
                forecasts.append(pred_2024)
            except Exception:
                predictions.append(series[-1] if series[-1] > 0 else 0)
        df_malaria["Predicted_Malaria_2025"] = predictions
        mse = mse_total / len(df_malaria) if len(df_malaria) > 0 else float('nan')
        mean_actual = np.mean(actuals) if actuals else float('nan')
        ss_tot = sum((a - mean_actual) ** 2 for a in actuals) if actuals else float('nan')
        ss_res = sum((a - f) ** 2 for a, f in zip(actuals, forecasts)) if actuals else float('nan')
        r2 = 1 - (ss_res / ss_tot) if ss_tot != 0 else float('nan')
        metrics = {
            "mse": mse,
            "r2": r2,
            "accuracy": r2 * 100 if not np.isnan(r2) else float('nan')
        }
        return df_malaria, metrics
    except Exception as e:
        st.error(f"Error in ARIMA forecasting: {str(e)}")
        return df_malaria, {"mse": float('nan'), "r2": float('nan'), "accuracy": float('nan')}

# Risk Classification
def classify_risk(cases, disease="malaria"):
    if disease == "malaria":
        if cases > 50000:
            return ("🔴 High Risk", "#e74c3c")
        elif cases > 25000:
            return ("🟠 Medium Risk", "#f39c12")
        elif cases > 10000:
            return ("🟡 Moderate Risk", "#f1c40f")
        else:
            return ("🟢 Low Risk", "#2ecc71")
    else:  # COVID-19
        if cases > 10000:
            return ("🔴 High Risk", "#e74c3c")
        elif cases > 5000:
            return ("🟠 Medium Risk", "#f39c12")
        elif cases > 1000:
            return ("🟡 Moderate Risk", "#f1c40f")
        else:
            return ("🟢 Low Risk", "#2ecc71")

# Format Number
def format_number(num):
    if pd.isna(num):
        return "N/A"
    if num >= 1_000_000:
        return f"{num / 1_000_000:.1f}M"
    elif num >= 1_000:
        return f"{num / 1_000:.1f}K"
    return int(num)

# Page: Home
if page == "Home":
    st.markdown("""
        <div class="card">
            <h2>Welcome to the Disease Prediction Dashboard</h2>
            <p style="color: #7f8c8d;">
                Upload datasets for COVID-19 and/or malaria to analyze and predict cases across India using LSTM, ARIMA, and ARIMAX models.
            </p>
        </div>
    """, unsafe_allow_html=True)

    st.subheader("Upload Datasets")
    col1, col2 = st.columns(2)
    with col1:
        st.markdown("**COVID-19 Data**")
        st.info("COVID-19 data is preloaded from January 2020 to May 2025.")
        if st.button("🚀 Process COVID-19 Data"):
            with st.spinner("Processing COVID-19 data..."):
                try:
                    raw_data = """Date_reported Country WHO_region New_cases Cumulative_cases New_deaths Cumulative_deaths
04-01-2020 India SEAR 0 0 0 0
05-01-2020 India SEAR 1 1 0 0
06-01-2020 India SEAR 2 3 1 1
"""
                    df_covid = parse_covid_data(raw_data)
                    if df_covid is None:
                        st.error("Failed to parse COVID-19 data.")
                        st.stop()
                    full_covid_data = generate_simulated_covid_data(df_covid)
                    if full_covid_data is None or full_covid_data['New_cases'].isna().any() or (full_covid_data['New_cases'] < 0).any():
                        st.error("Simulated COVID-19 data contains invalid values (NaN or negative).")
                        st.stop()
                    st.session_state.df_covid = full_covid_data
                    st.session_state.user_profile['analyses_run'] += 1
                    st.success("✅ COVID-19 data processed successfully!")
                except Exception as e:
                    st.error(f"Error processing COVID-19 data: {str(e)}")
                    st.stop()
    with col2:
        st.markdown("**Malaria Data**")
        uploaded_file = st.file_uploader("📂 Upload malaria dataset (CSV format)", type=["csv"], key="malaria_data_uploader")
        if uploaded_file is not None and st.button("🚀 Preprocess Malaria Dataset"):
            with st.spinner("Processing malaria dataset..."):
                try:
                    df_malaria = preprocess_malaria_data(uploaded_file)
                    if df_malaria is None:
                        st.error("Failed to process malaria dataset.")
                        st.stop()
                    st.session_state.df_malaria = df_malaria
                    st.session_state.user_profile['analyses_run'] += 1
                    st.success("✅ Malaria dataset preprocessed successfully!")
                except Exception as e:
                    st.error(f"Error processing malaria dataset: {str(e)}")
                    st.stop()


# Page: COVID-19 Analysis
if page == "COVID-19 Analysis":
    if st.session_state.df_covid is None:
        st.warning("COVID-19 data is not loaded. Please go to the Home page and process the COVID-19 data.")
        st.stop()
    
    st.markdown("<div class='card'><h2>COVID-19 Case and Death Forecast</h2></div>", unsafe_allow_html=True)
    df_covid = st.session_state.df_covid
    current_datetime = datetime(2025, 5, 27, 16, 13)  # Updated to current date and time
    st.write(f"**Current Date and Time:** {current_datetime.strftime('%A, %B %d, %Y %I:%M %p IST')}")
    st.markdown("""
        Showing historical data from January 2020 to May 27, 2025, with a forecast for the user-specified date range.
        **Note**: Forecast uses LSTM with a configurable look-back period. Actual numbers may vary due to changes in testing rates, public health measures, new variants, or vaccination status.
    """)

    historical_df = df_covid.set_index('Date_reported')[['New_cases', 'New_deaths', 'Cumulative_cases', 'Cumulative_deaths']]
    last_historical_date = historical_df.index.max()

    if historical_df.empty or historical_df['New_cases'].isna().all() or len(historical_df) < st.session_state.settings['look_back_period']:
        st.error(f"Insufficient or invalid COVID-19 data for forecasting. Please ensure the dataset has at least {st.session_state.settings['look_back_period']} days of valid data.")
        st.stop()

    st.subheader("Select Forecast Date Range")
    col1, col2 = st.columns(2)
    with col1:
        forecast_start_date = st.date_input(
            "Forecast Start Date",
            value=pd.to_datetime('2025-05-28'),
            min_value=(last_historical_date + timedelta(days=1)).date(),
            max_value=pd.to_datetime('2030-12-31').date()
        )
    with col2:
        forecast_end_date = st.date_input(
            "Forecast End Date",
            value=pd.to_datetime('2025-06-26'),
            min_value=(pd.to_datetime(forecast_start_date) + timedelta(days=1)).date(),
            max_value=pd.to_datetime('2030-12-31').date()
        )

    forecast_start_date = pd.to_datetime(forecast_start_date)
    forecast_end_date = pd.to_datetime(forecast_end_date)

    if forecast_end_date <= forecast_start_date:
        st.error("End date must be after start date.")
        st.stop()
    if forecast_start_date <= last_historical_date:
        st.error(f"Start date must be after the last historical date ({last_historical_date.strftime('%Y-%m-%d')}).")
        st.stop()

    forecast_steps = (forecast_end_date - last_historical_date).days
    if forecast_steps <= 0:
        st.error("Forecast period must be in the future.")
        st.stop()

    with st.spinner("Generating COVID-19 forecast..."):
        historical_days = len(historical_df['New_cases'])
        days_to_use = min(365, historical_days)
        if days_to_use < st.session_state.settings['look_back_period']:
            st.error(f"Insufficient data for LSTM forecasting. Only {days_to_use} days available, need at least {st.session_state.settings['look_back_period']}.")
            st.stop()

        forecast_dates = pd.date_range(start=last_historical_date + timedelta(days=1), periods=forecast_steps, freq='D')
        forecast_df = pd.DataFrame(index=forecast_dates)

        forecast_cases, mse_cases, r2_cases = lstm_forecast(historical_df['New_cases'][-days_to_use:], forecast_steps)
        forecast_deaths, mse_deaths, r2_deaths = lstm_forecast(historical_df['New_deaths'][-days_to_use:], forecast_steps)
        st.session_state.user_profile['analyses_run'] += 1

        forecast_df['New_cases'] = forecast_cases.values
        forecast_df['New_deaths'] = forecast_deaths.values
        last_cumulative_cases = historical_df['Cumulative_cases'].iloc[-1]
        last_cumulative_deaths = historical_df['Cumulative_deaths'].iloc[-1]
        forecast_df['Cumulative_cases'] = last_cumulative_cases + forecast_df['New_cases'].cumsum()
        forecast_df['Cumulative_deaths'] = last_cumulative_deaths + forecast_df['New_deaths'].cumsum()
        forecast_df['Type'] = 'Forecast'
        historical_df['Type'] = 'Historical'
        combined_df = pd.concat([historical_df, forecast_df])

        col1, col2 = st.columns(2)
        col1.metric("Cases MSE (Validation)", f"{mse_cases:.2f}" if not np.isnan(mse_cases) else "N/A", help="Mean Squared Error on validation set")
        col2.metric("Cases R² Score (Validation)", f"{r2_cases:.4f}" if not np.isnan(r2_cases) else "N/A", help="R² Score indicating model fit")
        col3, col4 = st.columns(2)
        col3.metric("Deaths MSE (Validation)", f"{mse_deaths:.2f}" if not np.isnan(mse_deaths) else "N/A", help="Mean Squared Error on validation set")
        col4.metric("Deaths R² Score (Validation)", f"{r2_deaths:.4f}" if not np.isnan(r2_deaths) else "N/A", help="R² Score indicating model fit")

    last_14_days = historical_df[-14:]['New_cases']
    last_7_days = historical_df[-7:]['New_cases']
    avg_7_day = last_7_days.mean()
    avg_14_day = last_14_days.mean()
    trend = ((avg_7_day - avg_14_day) / avg_14_day * 100) if avg_14_day != 0 else 0
    forecast_avg = forecast_df['New_cases'].mean()
    forecast_total = forecast_df['New_cases'].sum()

    col1, col2, col3 = st.columns(3)
    col1.metric("7-Day Average (Current)", format_number(avg_7_day), f"{trend:.1f}% {'↑' if trend >= 0 else '↓'}",
                delta_color="normal" if trend >= 0 else "inverse")
    col2.metric(f"Average Forecast ({forecast_start_date.strftime('%Y-%m-%d')} to {forecast_end_date.strftime('%Y-%m-%d')})",
                format_number(forecast_avg))
    col3.metric(f"Total Forecast Cases ({forecast_start_date.strftime('%Y-%m-%d')} to {forecast_end_date.strftime('%Y-%m-%d')})",
                format_number(forecast_total))

    view = st.radio("Select View", ["All Data", "Recent (90 Days)", "Forecast Focus"], horizontal=True)
    if view == "Recent (90 Days)":
        display_df = combined_df[-120:]
    elif view == "Forecast Focus":
        display_df = combined_df[-60:]
    else:
        display_df = combined_df

    if display_df.empty or display_df['New_cases'].isna().all():
        st.error("No valid data available to plot COVID-19 cases.")
        st.stop()
    display_df.index = pd.to_datetime(display_df.index)
    fig_cases = go.Figure()
    fig_cases.add_trace(go.Scatter(
        x=display_df.index, y=display_df['New_cases'], mode='lines', name='Daily New Cases', line=dict(color='#3498db')))
    fig_cases.add_trace(go.Scatter(
        x=display_df[display_df['Type'] == 'Forecast'].index, y=display_df[display_df['Type'] == 'Forecast']['New_cases'],
        mode='lines', name='Forecast Cases', line=dict(color='#e74c3c', dash='dash')))
    fig_cases.update_layout(
        title="COVID-19 New Cases: Historical and Forecasted (LSTM)", xaxis_title="Date", yaxis_title="New Cases",
        height=400, template="plotly_white", title_x=0.5)
    st.plotly_chart(fig_cases, use_container_width=True)

    if display_df.empty or display_df['New_deaths'].isna().all():
        st.error("No valid data available to plot COVID-19 deaths.")
        st.stop()
    fig_deaths = go.Figure()
    fig_deaths.add_trace(go.Scatter(
        x=display_df.index, y=display_df['New_deaths'], mode='lines', name='Daily New Deaths', line=dict(color='#2ecc71')))
    fig_deaths.add_trace(go.Scatter(
        x=display_df[display_df['Type'] == 'Forecast'].index, y=display_df[display_df['Type'] == 'Forecast']['New_deaths'],
        mode='lines', name='Forecast Deaths', line=dict(color='#f39c12', dash='dash')))
    fig_deaths.update_layout(
        title="COVID-19 New Deaths: Historical and Forecasted (LSTM)", xaxis_title="Date", yaxis_title="New Deaths",
        height=400, template="plotly_white", title_x=0.5)
    st.plotly_chart(fig_deaths, use_container_width=True)

    st.subheader(f"Forecast from {forecast_start_date.strftime('%Y-%m-%d')} to {forecast_end_date.strftime('%Y-%m-%d')}")
    forecast_display = forecast_df[['New_cases', 'Cumulative_cases']].copy()
    forecast_display['New_cases'] = forecast_display['New_cases'].round(0).astype(int)
    forecast_display['Cumulative_cases'] = forecast_display['Cumulative_cases'].round(0).astype(int)
    forecast_display = forecast_display.reset_index().rename(columns={'index': 'Date'})
    forecast_display['Date'] = forecast_display['Date'].dt.strftime('%d-%m-%Y')
    st.dataframe(forecast_display.head(10).style.set_table_styles([
        {'selector': 'th', 'props': [('background-color', '#34495e'), ('color', 'white')]},
        {'selector': 'td', 'props': [('border', '1px solid #ddd')]}
    ]), use_container_width=True)
    if len(forecast_display) > 10:
        st.write(f"Showing 10 of {len(forecast_display)} forecast days")








# Page: Malaria Analysis
if page == "Malaria Analysis":
    if st.session_state.df_malaria is None:
        st.warning("Malaria data is not loaded. Please go to the Home page and upload a malaria dataset.")
        st.stop()
    
    st.markdown("<div class='card'><h2>Malaria Case Prediction</h2></div>", unsafe_allow_html=True)
    df_malaria = st.session_state.df_malaria

    st.header("📈 Data Visualizations")
    with st.spinner("Generating visualizations..."):
        viz_data = generate_malaria_visualizations(df_malaria)
    with st.container():
        if 'corr_matrix' in viz_data:
            st.subheader("Correlation Matrix")
            st.pyplot(viz_data['corr_matrix'])
            plt.close(viz_data['corr_matrix'])
        if 'kde_plot' in viz_data:
            st.subheader("Malaria Cases Distribution (2020-2025)")
            st.pyplot(viz_data['kde_plot'])
            plt.close(viz_data['kde_plot'])
        if 'top_states' in viz_data:
            st.subheader("Top 10 States by Average Malaria Cases (2020-2024)")
            st.pyplot(viz_data['top_states'])
            plt.close(viz_data['top_states'])

    st.header("🔧 Feature Engineering")
    with st.spinner("Creating features..."):
        df_malaria, feat_viz = perform_malaria_feature_engineering(df_malaria)
        st.session_state.df_malaria = df_malaria
        st.session_state.user_profile['analyses_run'] += 1
    st.success("Feature engineering completed.")
    with st.expander("📊 Updated Dataset with Features", expanded=False):
        st.dataframe(df_malaria.style.set_table_styles([
            {'selector': 'th', 'props': [('background-color', '#34495e'), ('color', 'white')]},
            {'selector': 'td', 'props': [('border', '1px solid #ddd')]}
        ]))
    st.subheader("Feature Analysis Visualizations")
    if 'risk_category' in feat_viz:
        st.pyplot(feat_viz['risk_category'])
        plt.close(feat_viz['risk_category'])
    if 'state_risk' in feat_viz:
        st.pyplot(feat_viz['state_risk'])
        plt.close(feat_viz['state_risk'])

    st.header("🤖 ARIMA Time Series Prediction Model")
    with st.spinner("Running ARIMA model..."):
        df_malaria, metrics = run_malaria_arima(df_malaria)
        st.session_state.df_malaria = df_malaria
        st.session_state.user_profile['analyses_run'] += 1
    col1, col2, col3 = st.columns(3)
    col1.metric("MSE", f"{metrics['mse']:.2f}" if not np.isnan(metrics['mse']) else "N/A", help="Mean Squared Error of the model")
    col2.metric("R² Score", f"{metrics['r2']:.4f}" if not np.isnan(metrics['r2']) else "N/A", help="R² Score indicating model fit")
    col3.metric("Accuracy", f"{metrics['accuracy']:.2f}%" if not np.isnan(metrics['accuracy']) else "N/A", help="Accuracy based on R²")

    st.header("📊 Custom Malaria Trend Analysis")
    col1, col2 = st.columns([1, 2])
    with col1:
        selected_state_custom = st.selectbox(
            "Select State:",
            df_malaria['STATE_UT'].unique(),
            index=df_malaria['STATE_UT'].tolist().index('GOA') if 'GOA' in df_malaria['STATE_UT'].tolist() else 0,
            key='malaria_state_custom_selector')
        year_range = st.slider(
            "Select Year Range:",
            min_value=2020,
            max_value=2025,
            value=(2020, 2023),
            step=1,
            key='malaria_year_range_selector')
        st.subheader(f"Data Table")
        state_data_custom = df_malaria[df_malaria['STATE_UT'] == selected_state_custom].iloc[0]
        years = list(range(2020, 2026))
        cases = [
            state_data_custom['Malaria_2020'],
            state_data_custom['Malaria_2021'],
            state_data_custom['Malaria_2022'],
            state_data_custom['Malaria_2023'],
            state_data_custom['Malaria_2024'],
            state_data_custom['Predicted_Malaria_2025']
        ]
        cases = [0 if pd.isna(x) else x for x in cases]
        filtered_years = [y for y in years if year_range[0] <= y <= year_range[1]]
        filtered_cases = [cases[i] for i, y in enumerate(years) if year_range[0] <= y <= year_range[1]]
        filtered_types = ["Actual" if y < 2025 else "Forecast" for y in filtered_years]
        display_data_custom = {
            "Year": filtered_years,
            "Cases": filtered_cases,
            "Type": filtered_types
        }
        st.dataframe(pd.DataFrame(display_data_custom).style.set_table_styles([
            {'selector': 'th', 'props': [('background-color', '#34495e'), ('color', 'white')]},
            {'selector': 'td', 'props': [('border', '1px solid #ddd')]}
        ]))
    with col2:
        st.subheader(f"Trend Visualization")
        sns.set_style('darkgrid')  # Fixed: Use Seaborn's darkgrid style
        fig_custom = plt.figure(figsize=(10, 5))
        ax_custom = fig_custom.add_subplot(111)
        actual_years = [y for y in filtered_years if y < 2025]
        actual_cases = [cases[i] for i, y in enumerate(years) if year_range[0] <= y < 2025 and y <= year_range[1]]
        forecast_years = [y for y in filtered_years if y >= 2025]
        forecast_cases = [cases[i] for i, y in enumerate(years) if y >= 2025 and year_range[0] <= y <= year_range[1]]
        if actual_years:
            ax_custom.plot(actual_years, actual_cases, marker='o', linestyle='-', color='#3498db', label='Actual', linewidth=2)
        plot_years = actual_years[-1:] + forecast_years if actual_years and forecast_years else forecast_years
        plot_cases = [actual_cases[-1]] + forecast_cases if actual_years and forecast_years else forecast_cases
        if plot_years:
            ax_custom.plot(plot_years, plot_cases, marker='o', linestyle='--', color='#e74c3c', label='Forecast', linewidth=2)
        ax_custom.set_title(f"Malaria Cases Trend ({year_range[0]}-{year_range[1]})", fontsize=14, pad=15)
        ax_custom.set_xlabel("Year", fontsize=12)
        ax_custom.set_ylabel("Number of Cases", fontsize=12)
        ax_custom.grid(True, linestyle='--', alpha=0.7)
        ax_custom.legend()
        if 2025 in filtered_years:
            ax_custom.axvspan(2024.5, 2025.5, color='#f1c40f', alpha=0.1)
            ax_custom.text(2024.8, max(cases)*0.9, 'Forecast', color='#e74c3c', fontsize=10)
        st.pyplot(fig_custom)
        plt.close(fig_custom)

    st.header("🔮 Top Predictions for 2025")
    tab1, tab2 = st.tabs(["📊 Top 10 States", "📋 All States"])
    with tab1:
        top10 = df_malaria[['STATE_UT', 'Predicted_Malaria_2025']].sort_values(
            by='Predicted_Malaria_2025', ascending=False).head(10)
        sns.set_style('darkgrid')  # Fixed: Use Seaborn's darkgrid style
        fig_top, ax_top = plt.subplots(figsize=(10, 5))
        sns.barplot(data=top10, x='Predicted_Malaria_2025', y='STATE_UT', palette='coolwarm', ax=ax_top)
        ax_top.set_title("Top 10 Predicted Malaria Cases for 2025", fontsize=14, pad=15)
        ax_top.set_xlabel("Predicted Cases", fontsize=12)
        ax_top.set_ylabel("State/UT", fontsize=12)
        st.pyplot(fig_top)
        plt.close(fig_top)
    with tab2:
        df_display = df_malaria[['STATE_UT', 'Malaria_2020', 'Malaria_2021', 'Malaria_2022',
                                 'Malaria_2023', 'Malaria_2024', 'Predicted_Malaria_2025']].copy()
        df_display[['Malaria_2020', 'Malaria_2021', 'Malaria_2022',
                    'Malaria_2023', 'Malaria_2024', 'Predicted_Malaria_2025']] = df_display[[
            'Malaria_2020', 'Malaria_2021', 'Malaria_2022',
            'Malaria_2023', 'Malaria_2024', 'Predicted_Malaria_2025'
        ]].apply(lambda x: x.fillna(0).astype(int))
        st.dataframe(df_display.sort_values(by='Predicted_Malaria_2025', ascending=False).style.set_table_styles([
            {'selector': 'th', 'props': [('background-color', '#34495e'), ('color', 'white')]},
            {'selector': 'td', 'props': [('border', '1px solid #ddd')]}
        ]))

    st.header("📊 Annual Malaria Risk by State")
    selected_state = st.selectbox(
        "Select State/UT:",
        options=sorted(df_malaria["STATE_UT"].unique()),
        key='malaria_risk_state_selector')
    available_years = ['2020', '2021', '2022', '2023', '2024', '2025']
    selected_year = st.selectbox(
        "Select Year:",
        options=available_years,
        key='malaria_risk_year_selector')
    state_data = df_malaria[df_malaria['STATE_UT'] == selected_state].iloc[0]
    years = ['2020', '2021', '2022', '2023', '2024', '2025']
    cases = [state_data[f'Malaria_{year}'] for year in years[:-1]] + [state_data['Predicted_Malaria_2025']]
    cases = [0 if pd.isna(x) else x for x in cases]
    risk_data = [classify_risk(c, "malaria") for c in cases]
    risk_df = pd.DataFrame({
        'Year': years,
        'Cases': cases,
        'Risk Category': [r[0] for r in risk_data],
        'Color': [r[1] for r in risk_data]
    })
    st.subheader(f"Risk Assessment for {selected_state} in {selected_year}")
    selected_year_data = risk_df[risk_df['Year'] == selected_year].iloc[0]
    st.write(f"Year: {selected_year_data['Year']}")
    st.write(f"Number of Cases: {format_number(selected_year_data['Cases'])}")
    st.markdown(f"Risk Category: <span style='color:{selected_year_data['Color']}'>{selected_year_data['Risk Category']}</span>", unsafe_allow_html=True)

    st.header("🗺️ Predicted 2025 Malaria Risk by State")
    df_malaria['Risk_2025'] = df_malaria['Predicted_Malaria_2025'].apply(lambda x: classify_risk(x, "malaria")[0])
    color_map = {
        "🔴 High Risk": "#e74c3c",
        "🟠 Medium Risk": "#f39c12",
        "🟡 Moderate Risk": "#f1c40f",
        "🟢 Low Risk": "#2ecc71"
    }
    try:
        fig = px.choropleth(
            df_malaria,
            geojson="https://gist.githubusercontent.com/jbrobst/56c13bbbf9d97d187fea01ca62ea5112/raw/e388c4cae20aa53cb5090210a42ebb9b765c0a36/india_states.geojson",
            featureidkey='properties.ST_NM',
            locations='STATE_UT',
            color='Risk_2025',
            color_discrete_map=color_map,
            category_orders={"Risk_2025": ["🔴 High Risk", "🟠 Medium Risk", "🟡 Moderate Risk", "🟢 Low Risk"]},
            title='Predicted Malaria Risk for 2025',
            hover_data={'Predicted_Malaria_2025': ':,.0f', 'STATE_UT': True},
            labels={'Risk_2025': 'Risk Category'}
        )
        fig.update_geos(
            fitbounds="locations",
            visible=False,
            projection_type="mercator"
        )
        fig.update_layout(
            height=600,
            margin={"r":0,"t":40,"l":0,"b":0},
            legend_title_text='Risk Category',
            title_font_size=20,
            title_x=0.5
        )
        st.plotly_chart(fig, use_container_width=True)
    except Exception as e:
        st.error(f"Error rendering choropleth map: {str(e)}")
    st.caption("""
        **Malaria Risk Classification:**  
        🔴 High Risk (>50,000 cases) | 🟠 Medium Risk (25,000-50,000)  
        🟡 Moderate Risk (10,000-25,000) | 🟢 Low Risk (<10,000)
    """)

# Page: Combined Insights
if page == "Combined Insights":
    st.markdown("<div class='card'><h2>Combined Insights: COVID-19 and Malaria</h2></div>", unsafe_allow_html=True)
    if st.session_state.df_covid is None and st.session_state.df_malaria is None:
        st.warning("Please upload and process datasets for COVID-19 and/or malaria on the Home page to view combined insights.")
        st.stop()

    if st.session_state.df_covid is not None and st.session_state.df_malaria is not None:
        df_covid = st.session_state.df_covid
        df_malaria = st.session_state.df_malaria

        df_covid['Year'] = df_covid['Date_reported'].dt.year
        covid_yearly = df_covid.groupby('Year')['New_cases'].sum().reset_index()
        covid_yearly['Disease'] = 'COVID-19'

        malaria_cols = [f'Malaria_{y}' for y in range(2020, 2025)] + ['Predicted_Malaria_2025']
        years = list(range(2020, 2026))
        malaria_yearly = pd.DataFrame({
            'Year': years,
            'New_cases': [df_malaria[col].sum() if col in df_malaria.columns else 0 for col in malaria_cols]
        })
        malaria_yearly['Disease'] = 'Malaria'
        malaria_yearly['New_cases'] = malaria_yearly['New_cases'].round(0).astype(int)

        combined_yearly = pd.concat([covid_yearly, malaria_yearly])

        st.subheader("Annual Case Trends: COVID-19 vs. Malaria")
        try:
            fig_combined = px.line(
                combined_yearly,
                x='Year',
                y='New_cases',
                color='Disease',
                title='Annual Case Trends (2020-2025)',
                labels={'New_cases': 'Total Cases', 'Year': 'Year'},
                color_discrete_map={'COVID-19': '#3498db', 'Malaria': '#2ecc71'}
            )
            malaria_2025 = combined_yearly[(combined_yearly['Disease'] == 'Malaria') & (combined_yearly['Year'] >= 2024)]
            fig_combined.add_trace(go.Scatter(
                x=malaria_2025['Year'],
                y=malaria_2025['New_cases'],
                mode='lines',
                name='Malaria (Forecast)',
                line=dict(color='#2ecc71', dash='dash'),
                showlegend=False
            ))
            fig_combined.update_layout(
                height=400,
                template="plotly_white",
                title_x=0.5,
                yaxis=dict(title='Total Cases (Log Scale)', type='log')
            )
            st.plotly_chart(fig_combined, use_container_width=True)
        except Exception as e:
            st.error(f"Error plotting combined trends: {str(e)}")

        st.subheader("Risk Comparison for 2024")
        covid_2024_cases = df_covid[df_covid['Year'] == 2024]['New_cases'].sum()
        malaria_2024_cases = df_malaria['Malaria_2024'].sum().round(0).astype(int)
        covid_risk = classify_risk(covid_2024_cases, "covid")[0]
        malaria_risk = classify_risk(malaria_2024_cases, "malaria")[0]

        col1, col2 = st.columns(2)
        col1.metric("COVID-19 Risk (2024)", covid_risk, f"{format_number(covid_2024_cases)} cases")
        col2.metric("Malaria Risk (2024)", malaria_risk, f"{format_number(malaria_2024_cases)} cases")

        st.subheader("Model Accuracy Comparison")
        historical_df = df_covid.set_index('Date_reported')['New_cases']
        forecast_steps = 30
        _, mse_cases, r2_cases = lstm_forecast(historical_df[-365:], forecast_steps)
        covid_accuracy = r2_cases * 100 if not np.isnan(r2_cases) else float('nan')
        _, malaria_metrics = run_malaria_arima(df_malaria)
        malaria_accuracy = malaria_metrics['accuracy']
        st.session_state.user_profile['analyses_run'] += 1

        col1, col2 = st.columns(2)
        col1.metric("COVID-19 LSTM Accuracy", f"{covid_accuracy:.2f}%" if not np.isnan(covid_accuracy) else "N/A",
                    help="Accuracy based on R² score for LSTM model on validation set")
        col2.metric("Malaria ARIMA Accuracy", f"{malaria_accuracy:.2f}%" if not np.isnan(malaria_accuracy) else "N/A",
                    help="Accuracy based on R² score for ARIMA model")
    else:
        st.info("Please upload both datasets to view combined insights.")

# Page: Profile
if page == "Profile":
    st.markdown("<div class='card'><h2>👤 User Profile</h2></div>", unsafe_allow_html=True)
    st.subheader("User Information")
    col1, col2 = st.columns(2)
    with col1:
        st.write(f"Name: {st.session_state.user_profile['name'] or 'Not set'}")
        st.write(f"Email: {st.session_state.user_profile['email'] or 'Not set'}")
    with col2:
        st.write(f"Analyses Run: {st.session_state.user_profile['analyses_run']}")
    with st.form("profile_form"):
        st.subheader("Edit Profile")
        name = st.text_input("Name", value=st.session_state.user_profile['name'])
        email = st.text_input("Email", value=st.session_state.user_profile['email'])
        submitted = st.form_submit_button("💾 Save Profile")
        if submitted:
            if email and '@' not in email:
                st.error("Please enter a valid email address.")
            else:
                st.session_state.user_profile['name'] = name
                st.session_state.user_profile['email'] = email
                st.success("Profile updated successfully!")
                st.rerun()
    st.subheader("Analysis History")
    if st.session_state.user_profile['analyses_run'] > 0:
        st.write(f"You have run {st.session_state.user_profile['analyses_run']} analyses.")
        st.info("Detailed analysis history is not yet implemented. Future updates may include logs of past forecasts.")
    else:
        st.write("No analyses have been run yet.")
        


# Page: Settings
if page == "Settings":
    st.markdown("<div class='card'><h2>⚙️ Settings</h2></div>", unsafe_allow_html=True)
    st.subheader("Dashboard Configuration")
    
    with st.form("settings_form"):
        st.subheader("Appearance")
        theme = st.selectbox("Theme", ["Light", "Dark"], index=["Light", "Dark"].index(st.session_state.settings['theme']))
        
        st.subheader("Forecast Parameters")
        look_back_period = st.slider(
            "LSTM Look-Back Period (days)",
            min_value=30,
            max_value=180,
            value=st.session_state.settings['look_back_period'],
            step=10,
            help="Number of past days to use for LSTM forecasting. Higher values may capture longer trends but require more data."
        )
        
        submitted = st.form_submit_button("💾 Save Settings")
        if submitted:
            st.session_state.settings['theme'] = theme
            st.session_state.settings['look_back_period'] = look_back_period
            st.success("Settings saved successfully!")
            apply_theme(theme)
            st.rerun()

    st.subheader("Current Settings")
    st.write(f"**Theme**: {st.session_state.settings['theme']}")
    st.write(f"**LSTM Look-Back Period**: {st.session_state.settings['look_back_period']} days")

# Sidebar Reset Button
if st.sidebar.button("🔄 Reset App"):
    st.session_state.df_covid = None
    st.session_state.df_malaria = None
    st.session_state.user_profile = {'name': '', 'email': '', 'analyses_run': 0}
    st.session_state.settings = {'theme': 'Light', 'look_back_period': 60}
    st.cache_data.clear()
    st.rerun()
